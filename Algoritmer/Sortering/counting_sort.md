# Counting sort

<!-- 
1. Kjenne den formelle definisjonen av det generelle problemet den løser
2. Kjenne til eventuelle tilleggskrav den stiller for å være korrekt
3. Vite hvordan den oppfører seg; kunne utføre algoritmen, trinn for trinn!
4. Forstå korrekthetsbeviset; hvordan og hvorfor virker algoritmen egentlig?
5. Kjenne til eventuelle styrker eller svakheter, sammenlignet med andre
6. Kjenne kjøretidene under ulike omstendigheter, og forstå utregningen
-->

## Quick-facts:

* Stabil
* Sorterer basert på at alle input-elementene *n* er heltall med en range mellom 0 og *k*.
* Er mest effektiv når nøkkelvariasjonen ikke er særlig større enn mengden verdier (*k* < *n*)

## Den formelle definisjonen av det generelle problemet
<!-- Et problem er relasjonen mellom input og output -->

## Tilleggskrav for korrekthet
<!-- Korrekhet: algoritmer virker, gir det svaret den skal -->
<!-- Eks: Binary search må ha en sortert liste -->

* Listen må bestå av heltall-verdier

## Trinn for trinn
<!-- Pseudokode med forklaring -->

## Korrekthetsbevis
<!-- TBA -->

## Styrker og svakheter sammenlignet med andre

* Stabil
* **Counting sort** slår **Radix sort** hvis *n* >> *k*. (_Dette er også det tilfellet hvor algoritmen er mest effektiv._)

## Kjøretid og utregning
<!-- Under ulike omstendigheter -->

## Python kodeeksempel
